# GitLab CI/CD 配置文件
# GitLab 版本: 17.1.8 Community Edition
# 项目: frontend-practice
# 功能: 自动构建、推送 Docker 镜像、零停机部署

# 定义 CI/CD 阶段
stages:
  - build      # 构建 Docker 镜像
  - push       # 推送到 Harbor
  - deploy     # 部署到服务器
  - cleanup    # 清理旧镜像

# 全局变量
variables:
  # Harbor 配置
  HARBOR_URL: "192.168.152.56"
  HARBOR_PROJECT: "5"
  IMAGE_NAME: "${HARBOR_URL}/${HARBOR_PROJECT}/frontend-practice"

  # 部署服务器配置
  DEPLOY_SERVER: "192.168.153.111"
  DEPLOY_USER: "root"
  DEPLOY_DIR: "/root/zhailiang/frontend-practice"
  CONTAINER_PORT: "3000"

  # Docker 配置
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

  # GitLab Runner 镜像拉取策略
  # if-not-present: 优先使用本地镜像，避免频繁拉取导致超时
  PULL_POLICY: if-not-present

  # GitLab 17.1+ 支持的 CI/CD 功能
  FF_USE_FASTZIP: "true"           # 加速 artifacts 传输
  ARTIFACT_COMPRESSION_LEVEL: "fast" # 快速压缩
  CACHE_COMPRESSION_LEVEL: "fast"   # 快速缓存压缩

# 仅在推送到 master 分支时触发（GitLab 17.1+ 语法）
workflow:
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
      when: always
    - when: never

# ============================================
# 阶段 1: 构建 Docker 镜像
# ============================================
build-image:
  stage: build
  image: docker:24.0.5
  services:
    - name: docker:24.0.5-dind
      command:
        - /bin/sh
        - -c
        - |
          # 配置 Docker 镜像加速器
          mkdir -p /etc/docker
          cat > /etc/docker/daemon.json <<EOF
          {
            "registry-mirrors": [
              "https://docker.m.daocloud.io",
              "https://dockerproxy.com",
              "https://docker.mirrors.ustc.edu.cn"
            ]
          }
          EOF
          dockerd-entrypoint.sh || exit
  variables:
    GIT_STRATEGY: fetch
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - echo "Starting Docker image build"
    - echo "Commit hash ${CI_COMMIT_SHORT_SHA}"
    - echo "Build number ${CI_PIPELINE_IID}"
    - echo "Working directory $(pwd)"
    - ls -la  # 显示当前目录内容
  script:
    # 使用构建上下文（当前目录）而不是 Git 克隆
    - docker build --no-cache -t ${IMAGE_NAME}:${CI_PIPELINE_IID} .
    - docker tag ${IMAGE_NAME}:${CI_PIPELINE_IID} ${IMAGE_NAME}:latest
    - docker save ${IMAGE_NAME}:${CI_PIPELINE_IID} -o frontend-practice-${CI_PIPELINE_IID}.tar
    - echo "Docker image build completed"
  artifacts:
    paths:
      - frontend-practice-${CI_PIPELINE_IID}.tar
    expire_in: 1 hour
  tags:
    - docker
  only:
    - master

# ============================================
# 阶段 2: 推送镜像到 Harbor
# ============================================
push-to-harbor:
  stage: push
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    - echo "$HARBOR_PASSWORD" | docker login $HARBOR_URL -u $HARBOR_USERNAME --password-stdin
  script:
    - docker load -i frontend-practice-${CI_PIPELINE_IID}.tar
    - docker push ${IMAGE_NAME}:${CI_PIPELINE_IID}
    - docker push ${IMAGE_NAME}:latest
    - echo "Image pushed to Harbor successfully"
    - echo "Image URL ${IMAGE_NAME}:${CI_PIPELINE_IID}"
  after_script:
    - docker logout $HARBOR_URL
  dependencies:
    - build-image
  tags:
    - docker
  only:
    - master

# ============================================
# 阶段 3: 部署到生产服务器
# ============================================
deploy-to-production:
  stage: deploy
  image: alpine:latest
  variables:
    GIT_STRATEGY: none  # 部署阶段不需要代码
  before_script:
    - apk add --no-cache openssh-client bash curl
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $DEPLOY_SERVER >> ~/.ssh/known_hosts
  script:
    - echo "Starting deployment to production server"
    - scp -i ~/.ssh/id_rsa deploy.sh ${DEPLOY_USER}@${DEPLOY_SERVER}:${DEPLOY_DIR}/
    - |
      ssh -i ~/.ssh/id_rsa ${DEPLOY_USER}@${DEPLOY_SERVER} << EOF
        cd ${DEPLOY_DIR}
        chmod +x deploy.sh
        bash deploy.sh \
          ${IMAGE_NAME}:${CI_PIPELINE_IID} \
          ${HARBOR_URL} \
          ${HARBOR_USERNAME} \
          ${HARBOR_PASSWORD}
        if [ \$? -eq 0 ]; then
          echo "Deployment succeeded"
          exit 0
        else
          echo "Deployment failed"
          exit 1
        fi
      EOF
    - echo "=========================================="
    - echo "Deployment completed"
    - echo "Access URL http://${DEPLOY_SERVER}:3000"
    - echo "=========================================="
  dependencies:
    - push-to-harbor
  tags:
    - shell
  only:
    - master
  when: on_success

# ============================================
# 阶段 4: 清理旧镜像（可选）
# ============================================
cleanup-old-images:
  stage: cleanup
  image: alpine:latest
  variables:
    GIT_STRATEGY: none  # 清理阶段不需要代码
  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $DEPLOY_SERVER >> ~/.ssh/known_hosts
  script:
    - echo "Cleaning old images on server"
    - |
      ssh -i ~/.ssh/id_rsa ${DEPLOY_USER}@${DEPLOY_SERVER} << 'EOF'
        docker images 192.168.152.56/5/frontend-practice \
          --format "{{.ID}} {{.CreatedAt}}" | \
          sort -rk2 | tail -n +4 | awk '{print $1}' | \
          xargs -r docker rmi -f || true
        echo "Old images cleanup completed"
      EOF
  dependencies:
    - deploy-to-production
  tags:
    - shell
  only:
    - master
  when: on_success
  allow_failure: true  # 清理失败不影响整体部署

# ============================================
# 失败时发送通知（可选）
# ============================================
notify-on-failure:
  stage: .post
  image: alpine:latest
  variables:
    GIT_STRATEGY: none  # 通知阶段不需要代码
  script:
    - echo "Pipeline failed"
    - echo "Commit ${CI_COMMIT_SHORT_SHA}"
    - echo "Branch ${CI_COMMIT_BRANCH}"
    - echo "Build number ${CI_PIPELINE_IID}"
  when: on_failure
  only:
    - master
